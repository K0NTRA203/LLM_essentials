{"version":3,"file":"static/js/86.baa2c40c.chunk.js","mappings":"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","sources":["../node_modules/hark/hark.js","../node_modules/wildemitter/wildemitter.js"],"sourcesContent":["var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n","/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nmodule.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);\n"],"names":["audioContextType","WildEmitter","require","window","AudioContext","webkitAudioContext","audioContext","module","exports","stream","options","harker","sourceNode","fftBins","analyser","smoothing","interval","threshold","play","history","running","createAnalyser","fftSize","smoothingTimeConstant","Float32Array","frequencyBinCount","jquery","HTMLAudioElement","HTMLVideoElement","createMediaElementSource","createMediaStreamSource","connect","destination","speaking","suspend","resume","Object","defineProperty","get","state","onstatechange","emit","setThreshold","t","setInterval","i","stop","disconnect","speakingHistory","push","looper","setTimeout","currentVolume","maxVolume","getFloatFrequencyData","ii","length","getMaxVolume","shift","mixin","constructor","prototype","isWildEmitter","on","event","groupName","fn","this","callbacks","hasGroup","arguments","group","undefined","func","_groupName","once","self","off","apply","releaseGroup","item","len","handlers","splice","indexOf","listeners","args","slice","call","specialCallbacks","getWildcardCallbacks","concat","eventName","split","result"],"sourceRoot":""}